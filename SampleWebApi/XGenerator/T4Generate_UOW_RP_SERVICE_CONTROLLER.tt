<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".txt" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="EnvDTE" #>
<#@ include file="T4Helper.ttinclude" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#  //Set these options
    string EntityNamespace = "Core.Entities";
    string DbContextNamespace = "Infrastructure.Context";
    string efContext = "ApplicationDbContext"; //If Context is not in the same namespace rename this to the name of the context

    IServiceProvider serviceProvider = (IServiceProvider)this.Host;
    DTE dte = serviceProvider.GetService(typeof(DTE)) as DTE; 
    var project1 = FindProjectByName(dte, "Core");
    var classes = FindClasses(project1, EntityNamespace, "");
    var classNames = classes
                    .Select(currentClass => currentClass.Name)
                    .ToList();
    var project2 = FindProjectByName(dte, "Infrastructure");
    var dbcclass = FindClasses(project2, DbContextNamespace, "");
    var classWithDbContext = dbcclass.FirstOrDefault(currentClass => currentClass.Bases.OfType<CodeElement>().Any(currentBase => currentBase.Name == "DbContext"));
    if(classWithDbContext != null)
    {
        efContext = classWithDbContext.Name;
    }
#>
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
    var repositoryName =  properClassName + "Repository";
    (var key1,var key1Type) = GetKeyPropertyOfAClass(dte,project1,EntityNamespace+"."+properClassName);
#>
//////////////////////////////////////
// generated I<#= repositoryName #> //
//////////////////////////////////////
using Domain.Entities;

namespace Domain.Interfaces
{
    public interface I<#= repositoryName #> : IGenericRepository<<#= properClassName #>>
    {
        //Task<IEnumerable<<#= properClassName #>>> Get<#= properClassName #>ByName(string name);
    }
}
<# CreateFile("Domain", "Interfaces", "I"+repositoryName+".cs"); #>
<#
}
#>
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
    var repositoryName =  properClassName + "Repository";
    (var key1,var key1Type) = GetKeyPropertyOfAClass(dte,project1,EntityNamespace+"."+properClassName);
#>
/////////////////////////////////////
// generated <#= repositoryName #> //
/////////////////////////////////////
using Domain.Entities;
using Domain.Interfaces;
using Infrastructure.Persistence.Context;

namespace Infrastructure.Persistence.Repositories
{
    public class <#= properClassName #>Repository : GenericRepository<<#= properClassName #>>, I<#= properClassName #>Repository
    {
        public <#= properClassName #>Repository(ApplicationDbContext context) : base(context)
        {
            _context = context;
        }
        //public async Task<IEnumerable<<#= properClassName #>>> Get<#= properClassName #>ByName(string name)
        //{
        //    return await _context.Set<<#= properClassName #>>().Where(x => x.Name == name).ToListAsync();
        //}
    }
}
<# CreateFile("Infrastructure", "Persistence/Repositories", repositoryName+".cs"); #>
<#
}
#>
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
    var serviceName =  properClassName + "Service";
    (var key1,var key1Type) = GetKeyPropertyOfAClass(dte,project1,EntityNamespace+"."+properClassName);
#>
///////////////////////////////////
// generated I<#= serviceName #> //
///////////////////////////////////
using Domain.Entities;
using System.Linq.Expressions;

namespace Application.Interfaces
{
    public interface I<#= properClassName #>Service
    {
        Task<(bool IsSuccess, string? Message)> Add<#= properClassName #>(<#= properClassName #> entity);
        Task<(bool IsSuccess, IEnumerable<<#= properClassName #>> entities, string Message)> Find<#= properClassName #>(Expression<Func<<#= properClassName #>, bool>> expression);
        Task<(bool IsSuccess, IEnumerable<<#= properClassName #>> entities, string Message)> GetAll<#= properClassName #>();
        Task<(bool IsSuccess, <#= properClassName #>? entity, string Message)> Get<#= properClassName #>ById(<#= key1Type #> id);
        Task<(bool IsSuccess, string Message)> Remove<#= properClassName #>(<#= key1Type #> id);
        Task<(bool IsSuccess, string Message)> Update<#= properClassName #>(<#= properClassName #> entity);
    }
}
<# CreateFile("Application", "Interfaces", "I"+serviceName+".cs"); #>
<#
}
#>
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
    var serviceName =  properClassName + "Service";
    var repositoryName =  properClassName + "Repository";
    (var key1,var key1Type) = GetKeyPropertyOfAClass(dte,project1,EntityNamespace+"."+properClassName);
#>
//////////////////////////////////
// generated <#= serviceName #> //
//////////////////////////////////
using Application.Interfaces;
using Domain.Entities;
using Domain.Exceptions;
using Domain.Interfaces;
using System.Linq.Expressions;

namespace Application.Services
{
    public class <#= properClassName #>Service : I<#= properClassName #>Service
    {
        private readonly IRepositoryManager _repositoryManager;

        public SampleService(IRepositoryManager repositoryManager)
        {
            _repositoryManager = repositoryManager;
        }
        public async Task<(IEnumerable<<#= properClassName #>> entities, string Message)> Find<#= properClassName #>(Expression<Func<<#= properClassName #>, bool>> expression, CancellationToken cancellationToken = default)
        {
        {
            var items = await _repositoryManager.<#= properClassName #>Repository.Find(expression);
            return (items, "<#= properClassName #> records retrieved");
        }

        public async Task<(IEnumerable<<#= properClassName #>> entities, string Message)> GetAll<#= properClassName #>(CancellationToken cancellationToken = default)
        {
            var items = await _repositoryManager.<#= properClassName #>Repository.GetAll();
            return (items, "<#= properClassName #> records retrieved");
        }

        public async Task<(<#= properClassName #>? entity, string Message)> Get<#= properClassName #>ById(int id, CancellationToken cancellationToken = default)
        {
            var item = await _repositoryManager.<#= properClassName #>Repository.GetById(id);
            if (item == null)
            {
                throw new EntityKeyNotFoundException("<#= properClassName #>", id.ToString());
            }
            return (item, "<#= properClassName #> record retrieved");
        }

        public async Task<string> Add<#= properClassName #>(<#= properClassName #> entity, CancellationToken cancellationToken = default)
        {
            if (entity != null)
            {
                var item = await _repositoryManager.<#= properClassName #>Repository.GetById(entity.Id);
                if (item != null)
                {
                    throw new EntityKeyFoundException("<#= properClassName #>", entity.Id.ToString());
                }
                else
                {
                    await _repositoryManager.<#= properClassName #>Repository.Add(entity);
                    await _repositoryManager.UnitOfWork.CompleteAsync(cancellationToken);
                    return "<#= properClassName #> record added";
                }
            }
            throw new Exception("Add Error");
        }

        public async Task<string> Remove<#= properClassName #>(int id, CancellationToken cancellationToken = default)
        {
            var item = await _repositoryManager.<#= properClassName #>Repository.GetById(id);
            if (item == null)
            {
                throw new EntityKeyNotFoundException("<#= properClassName #>", id.ToString());
            }
            else
            {
                _repositoryManager.<#= properClassName #>Repository.Remove(item);
                await _repositoryManager.UnitOfWork.CompleteAsync(cancellationToken);
                return "<#= properClassName #> record deleted";
            }
        }

        public async Task<string> Update<#= properClassName #>(<#= properClassName #> entity, CancellationToken cancellationToken = default)
        {
            if (entity != null)
            {
                var item = await _repositoryManager.<#= properClassName #>Repository.GetById(entity.Id);
                if (item == null)
                {
                    throw new EntityKeyNotFoundException("<#= properClassName #>", entity.Id.ToString());
                }
                else
                {
                    //only place that need change if structure changes
                    //item.Name = entity.Name;
                    //item.Description = entity.Description;

                    _repositoryManager.<#= properClassName #>Repository.Update(item);
                    await _repositoryManager.UnitOfWork.CompleteAsync(cancellationToken);
                    return "<#= properClassName #> record updated";
                }
            }
            throw new Exception("Update Error");
        }
    }
}
<# CreateFile("Application", "Services", serviceName+".cs"); #>
<#
}
#>
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
    var controller =  properClassName + "Controller";
    (var key1,var key1Type) = GetKeyPropertyOfAClass(dte,project1,EntityNamespace+"."+properClassName);
#>
////////////////////////////////////////////////////////////
// generated <#= controller #> where Entity is the class //
////////////////////////////////////////////////////////////
using Application.Interfaces;
using Domain.Entities;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

// For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace Infrastructure.Presentation.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class <#= properClassName #>Controller : ControllerBase
    {
        private readonly ILogger<<#= properClassName #>Controller> logger;
        private readonly IServiceManager _serviceManager;

        public <#= properClassName #>Controller(IServiceManager serviceManager, ILogger<<#= properClassName #>Controller> logger)
        {
            _serviceManager = serviceManager;
            this.logger = logger;
        }
        // GET: api/<<#= properClassName #>Controller>
        [HttpGet]
        public async Task<IActionResult> Get()
        {
            var result = await _serviceManager.<#= properClassName #>Service.GetAll<#= properClassName #>();
            return Ok(result.entities);
        }

        // GET api/<<#= properClassName #>Controller>/5
        [HttpGet("{id}")]
        public async Task<IActionResult> Get(<#= key1Type #> id)
        {
            var result = await _serviceManager.<#= properClassName #>Service.Get<#= properClassName #>ById(id);
            return Ok(result.entity);
        }

        // POST api/<<#= properClassName #>Controller>
        [HttpPost]
        public async Task<IActionResult> Post([FromBody] <#= properClassName #> entity)
        {
            var result = await _serviceManager.<#= properClassName #>Service.Add<#= properClassName #>(entity);
            return Ok(result);
        }

        // PUT api/<<#= properClassName #>Controller>/5
        [HttpPut()]
        public async Task<IActionResult> Put([FromBody] <#= properClassName #> entity)
        {
            var result = await _serviceManager.<#= properClassName #>Service.Update<#= properClassName #>(entity);
            return Ok(result);
        }

        // DELETE api/<<#= properClassName #>Controller>/5
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(<#= key1Type #> id)
        {
            var result = await _serviceManager.<#= properClassName #>Service.Remove<#= properClassName #>(id);
            return Ok(result);
        }
    }
}
<# CreateFile("Infrastructure", "Presentation/Controllers", controller+".cs"); #>
<#
}
#>
///////////////////////////////
// generated IServiceManager //
///////////////////////////////
namespace Application.Interfaces
{
    public interface IServiceManager
    {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        I<#= properClassName #>Service <#= properClassName #>Service { get; }
<#
}
#>
    }
}
<# CreateFile("Application", "Interfaces","IServiceManager.cs"); #>
//////////////////////////////
// generated ServiceManager //
//////////////////////////////
using Application.Interfaces;
using Domain.Interfaces;

namespace Application.Services
{
    public class ServiceManager : IServiceManager
    {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        private readonly Lazy<I<#= properClassName #>Service> _lazy<#= properClassName #>Service;
<#
}
#>
        public ServiceManager(IRepositoryManager repositoryManager)
        {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
            _lazy<#= properClassName #>Service = new Lazy<I<#= properClassName #>Service>(() => new <#= properClassName #>Service(repositoryManager));
<#
}
#
        }
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        public I<#= properClassName #>Service <#= properClassName #>Service => _lazy<#= properClassName #>Service.Value;
<#
}
#
    }
}
<# CreateFile("Application", "Services","ServiceManager.cs"); #>
///////////////////////////////
// generated IRepositoryManager //
///////////////////////////////
namespace Domain.Interfaces
{
    public interface IRepositoryManager
    {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        I<#= properClassName #>Repository <#= properClassName #>Repository { get; }
<#
}
#>
        IUnitOfWork UnitOfWork { get; }
    }
}
<# CreateFile("Domain", "Interfaces","IRepositoryManager.cs"); #>
//////////////////////////////
// generated RepositoryManager //
//////////////////////////////
using Domain.Interfaces;
using Infrastructure.Persistence.Context;

namespace Infrastructure.Persistence.Repositories
{
    public class RepositoryManager : IRepositoryManager
    {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        private readonly Lazy<I<#= properClassName #>Repository> _lazy<#= properClassName #>Repository;
<#
}
#>
        private readonly Lazy<IUnitOfWork> _lazyUnitOfWork;

        public RepositoryManager(ApplicationDbContext context)
        {
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
            _lazy<#= properClassName #>Repository = new Lazy<I<#= properClassName #>Repository>(() => new <#= properClassName #>Repository(context));
<#
}
#
            _lazyUnitOfWork = new Lazy<IUnitOfWork>(() => new UnitOfWork(context));
        }
<#foreach(string className in classNames)
{
    var properClassName = GetProperClassName(className);
#>
        public I<#= properClassName #>Repository <#= properClassName #>Repository => _lazy<#= properClassName #>Repository.Value;
<#
}
#
        public IUnitOfWork UnitOfWork => _lazyUnitOfWork.Value;
    }
}
<# CreateFile("Infrastructure", "Persistence/Repository","RepositoryManager.cs"); #>